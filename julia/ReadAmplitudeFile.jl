#---------------------------------------------------------------------- 
@doc """
      DynamicalSystem(Coef::AbstractMatrix{T},V::Union{AbstractVector{T},T}) where {T <: Number}

      Evaluate ∂v/∂t = F(v) where, F(v) is defined by the matrix Coef.

      Coef is the matrix of coefficients generated by all the possibl non-linear terms of the 
      variables in V. The ordering of terms in important. The Coef matrix should correspond to 
      the nonlinear terms for the given ordering of variables in V.

"""
function DynamicalSystem1(Coef::AbstractMatrix{T},V::Union{AbstractVector{T},T}) where {T <: Number}

  nv     = length(V)
  r,pmax = size(Coef)

  s = T(0)
  for p in 1:pmax
    nt    = CenterManifold.NInteractionTerms(p,nv)
    pvec  = zeros(Int,1,nv)
    row   = 0
    for j in 1:nt
      pw   = view(pvec,1,:)
      row  = CenterManifold.NextRow!(pw,p,row)
      vvec = CenterManifold.InteractionNTuples(pvec,p,nv)

      t    = T(1)
      for k in 1:p
        l  = vvec[k]    # variable number
        t  = t*V[l]
      end
      s = s + Coef[j,p]*t
    end     # for j in 1:nt
  end       # for p in 1:pmax

  return s
end
#----------------------------------------------------------------------
@doc """
      EvolveSystemRK4(Coef::AbstractMatrix{T},v::{T},μ::{T},dt::Float64,nsteps::Int) where {T <: Number}

      Integrate ∂v/∂t = F(v) where, F(v) is defined by the matrix Coef.

      See DynamicalSystem for more information on Coef.

"""
function EvolveSystemRK4(Coef::AbstractMatrix{T},v::T,μ::T,dt::Float64,nsteps::Int) where {T <: Number}

  two = T(2)
  six = T(6)

  for i in 1:nsteps

    # 4th Order Runge-Kutta Steps
    u   = [μ; v; v']
    du  = DynamicalSystem1(Coef,u)
    v1  = v + (dt/two)*du

    u1  = [μ; v1; v1']
    du1 = DynamicalSystem1(Coef,u1)
    v2  = v + (dt/two)*du1

    u2  = [μ; v2; v2']
    du2 = DynamicalSystem1(Coef,u2)
    v3  = v + dt*du2

    u3  = [μ; v3; v3']
    du3 = DynamicalSystem1(Coef,u3)
    
    v   = v + (dt/six)*(du + two*du1 + two*du2 + du3)
  end  

  return v
end
#----------------------------------------------------------------------
@doc """
      EvolveSystemRK2(Coef::AbstractMatrix{T},v::{T},μ::{T},dt::Float64,nsteps::Int) where {T <: Number}

      Integrate ∂v/∂t = F(v) where, F(v) is defined by the matrix Coef.

      See DynamicalSystem for more information on Coef.

"""
function EvolveSystemRK2(Coef::AbstractMatrix{T},v::T,μ::T,dt::Float64,nsteps::Int) where {T <: Number}

  α   = 0.5       # Mid-Point Method
  # α   = 1.0       # Heun's Method
  # α   = 2.0/3.0   # Ralston's methods
  two = T(2)
  six = T(6)

  for i in 1:nsteps

    # 2nd Order Runge-Kutta Steps
    u   = [μ; v; v']
    du  = DynamicalSystem1(Coef,u)
    v1  = v + α*dt*du

    u1  = [μ; v1; v1']
    du1 = DynamicalSystem1(Coef,u1)
    
    v   = v + dt*((1.0 - 1.0/(2.0*α))*du + (1.0/(2.0*α))*du1)
  end  

  return v
end
#----------------------------------------------------------------------


@doc """
      DynamicalSystemN(Coef::AbstractMatrix{T},V::Union{AbstractVector{T},T}) where {T <: Number}

      Evaluate ∂v/∂t = F(v) where, F(v) is defined by the matrix Coef.

      Coef is the matrix of coefficients generated by all the possibl non-linear terms of the 
      variables in V. The ordering of terms in important. The Coef matrix should correspond to 
      the nonlinear terms for the given ordering of variables in V.

"""
function DynamicalSystemN(Coef::AbstractVector{Matrix{T}},V::AbstractVector{T}) where {T <: Number}

  neqs = length(Coef)
  nv   = length(V)

  Vn   = T(0)*V

  for k in 1:neqs
    DS = Coef[k]  
    r,pmax = size(DS)
    s  = T(0)
    for p in 1:pmax
      nt    = CenterManifold.NInteractionTerms(p,nv)
      pvec  = zeros(Int,1,nv)
      row   = 0
      for j in 1:nt
        pw   = view(pvec,1,:)
        row  = CenterManifold.NextRow!(pw,p,row)
        vvec = CenterManifold.InteractionNTuples(pvec,p,nv)

        t    = T(1)
        for k in 1:p
          l  = vvec[k]    # variable number
          t  = t*V[l]
        end
        s = s + DS[j,p]*t
      end         # for j in 1:nt
    end           # for p in 1:pmax
    Vn[k] = s
  end             # for k in 1:neqs 

  return Vn
end
#----------------------------------------------------------------------

@doc """

      EvolveSystemN!(Coef::AbstractVector{AbstractMatrix{T}},X::AbstractVector{T},dt::Float64,nsteps::Int) where {T <: Number}

      Integrate ∂X/∂t = F(X) where, F(X) is defined by the matrix Coef.

      See DynamicalSystem for more information on Coef.

"""
function EvolveSystemN!(Coef::AbstractVector{Matrix{T}},X::AbstractVector{T},dt::Float64,nsteps::Int) where {T <: Number}

  two = T(2)
  six = T(6)

  nm  = length(Coef)
  nv  = length(X)

  @assert nm == nv "Unequal No. of Variables and Equations"

  for i in 1:nsteps
    # 4th Order Runge-Kutta Steps
    dx  = DynamicalSystemN(Coef,X)
    X1  = X .+ (dt/two)*dx

    dx1 = DynamicalSystemN(Coef,X1)
    X2  = X .+ (dt/two)*dx1

    dx2 = DynamicalSystemN(Coef,X2)
    X3  = X .+ dt*dx2

    dx3 = DynamicalSystemN(Coef,X3)
    
    for k in 1:nv
      X[k]   = X[k] + (dt/six)*(dx[k] + two*dx1[k] + two*dx2[k] + dx3[k])
    end  
  end  

  return nothing
end
#----------------------------------------------------------------------

function ReadAmplitudeFile(fname)

  io  = open(fname)

  # File Header
  str = readline(io)
  if !isempty(str)
    tup = split(str, ' ',keepempty=false)
    # tup[1] == "MOrder"
    # tup[2] == "="
    # tup[3] == "3"
    # tup[4] == ";"
    # tup[5] == "Mterms"
    # tup[6] == "="
    # tup[7] == "10"
    mord = parse(Int,tup[3])
    m    = parse(Int,tup[7])
  else
    return []
  end

  Coef = zeros(ComplexF64,m,mord)

  while !eof(io)
    # Order Header
    str = readline(io)
    if !isempty(str)
      tup = split(str, ' ',keepempty=false)
      # tup[1] == "Order"
      # tup[2] == "="
      # tup[3] == "1"
      # tup[4] == ";"
      # tup[5] == "Nterms"
      # tup[6] == "="
      # tup[7] == "3"
      ord = parse(Int,tup[3])
      n   = parse(Int,tup[7])

      for i in 1:n
        str = readline(io)
        tup = split(str, ' ',keepempty=false)
        # tup(1) == "x0x0..."
        # tup(2) == "0"
        # tup(3) == "1"
        # tup(4) == "2"
        # .
        # .
        # .
        # tup(ord+2) == "-7.29083568691558E-010"
        # tup(ord+3) == "7.84513756041383E-011"
        rval = parse(Float64,tup[ord+2])
        ival = parse(Float64,tup[ord+3])
        Coef[i,ord] = rval + im*ival
      end
    end
  end       # while (eof) 

  return Coef
end  
#---------------------------------------------------------------------- 






